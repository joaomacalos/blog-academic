---
title: Sankey's diagram in R
author: João Pedro S. Macalós
date: '2020-10-17'
slug: sankey-s-diagram-in-r
categories: [sfc]
tags: [sfc]
subtitle: ''
summary: ''
authors: []
lastmod: '2020-10-25T12:36:10+02:00'
featured: true
image:
  placement: 2
  focal_point: "Center"
  preview_only: true
projects: [sfc]
#output: blogdown::html_page
bibliography: references.bib
---

In this post I will explain how to create a Sankey's diagram to visualize a transactions-flow matrix of a SFC model.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load the packages used in this post:

```{r}
library(tidyverse)
library(ggalluvial)
library(networkD3)
library(sfcr)

##### Not in operator
'%!in%' <- function(x,y)!('%in%'(x,y))
```

The objective of this notebook is to show how to simulate the chapter 3 model (SIM model) of @godley2007monetary.


# SIM model

Define sectoral equations
```{r}
equations <- list(
  TX_s[t] ~ TX_d[t],
  YD[t] ~ W * N_s[t] - TX_s[t],
  C_d[t] ~ parh2 * YD[t] + parh3 * H_h[t-1],
  H_h[t] ~ YD[t] - C_d[t] + H_h[t-1],
  N_s[t] ~ N_d[t],
  N_d[t] ~ Y[t] / W,
  C_s[t] ~ C_d[t],
  G_s[t] ~ G_d[t],
  Y[t] ~ C_s[t] + G_s[t],
  TX_d[t] ~ parh1 * W * N_s[t],
  H_s[t] ~ G_d[t] - TX_d[t] + H_s[t-1]
)

```

Generate the model
```{r}
mod_sim <- sfcr_sim(equations = equations, 
                      t = 60,
                      exogenous = list("G_d" = 20), 
                      parameters = list(W = 1, parh1 = 0.2, parh2 = 0.6, parh3 = 0.4))

```

# Sankey's diagram


1. Calculate the variation in monetary balances and multiple the supply/demand for work by wages:

```{r}
mod_sim <- mod_sim %>%
  mutate(across(c(H_s, H_h), ~.x - lag(.x)),
         across(c(N_s, N_d), ~.x * W)) %>%
  select(-W) %>%
  drop_na()
```


2. Save the last observation, as we want the diagram in the steady state:

```{r}
sim_ss <- mod_sim %>% slice(59)
```

3. Look at the transactions matrix, as we need to reshape the data according to it. 

We must exclude the items that are not there, like disposable income (YD), Y, W, and the parameters:

```{r}
sim_ss <- sim_ss %>%
  pivot_longer(cols = -t) %>%
  filter(name %!in% c('YD', 'Y')) %>%
  filter(!str_detect(name, 'par'))
sim_ss
```
4. Consolidate the entries to have one per row on the transactions matrix:

```{r}
sim_ss <- sim_ss %>%
  mutate(name = str_remove_all(name, '_.')) %>%
  group_by(name) %>%
  summarize(value = mean(value)) %>%
  mutate(name = if_else(name == 'N', 'WB', name))
sim_ss
```

5. Map these flows with sectors, one tibble for inflows (+) and one for outflows (-):

```{r}
# Inflows (+ in the matrix)
sim_inflows <- sim_ss %>%
  mutate(sector = case_when(
    name == 'C' ~ 'pr',
    name == 'G' ~ 'pr',
    name == 'H' ~ 'gvt',
    name == 'WB' ~ 'hh',
    name == 'TX' ~ 'gvt'
  ))

# Outflows (- in the matrix)
sim_outflows <- sim_ss %>%
  mutate(sector = case_when(
    name == 'C' ~ 'hh',
    name == 'G' ~ 'gvt',
    name == 'H' ~ 'hh',
    name == 'WB' ~ 'pr',
    name == 'TX' ~ 'hh'
  ))
```


If these steps are not clear, I recommend [this article](https://towardsdatascience.com/using-networkd3-in-r-to-create-simple-and-clear-sankey-diagrams-48f8ba8a4ace) as it was the best tutorial I found on the internet on how to draw Sankey's diagrams on R.

Here, we must remember that a SFC Sankey's diagram is structured in three columns: 

> sector (outflows) $\rightarrow$ flows $\rightarrow$ sector (inflows)

6. Create the `nodes` tibble:

The objects in these columns are the `nodes` of the Sankey's diagram. They are the unique `name` entries (flows) and `sector` entries of the inflows and outflows tibbles. Since we repeat the sectors column, we must differentiate them in the code. I will do it by adding a numerical suffix to them.

Finally, we must give each unique entry a numeric id. Importantly, it must be zero indexed.

```{r}
sim_nodes <- tibble(name = c(unique(sim_inflows$name), 
                 unique(sim_inflows$sector), 
                 str_c(unique(sim_inflows$sector), '1')),
       node = 0:10)
```

7. Create the `links` tibble:

We do it by first `left_join`ing the data on names, and then on sector. The order of the joins matter. The first column `node.x` will map the flows and the second column `node.y` will map the sectors.


```{r}
links_sim_outflows <- sim_outflows %>%
  left_join(sim_nodes, by = c('name')) %>%
  left_join(sim_nodes, by = c('sector' = 'name')) %>%
  rename(source = node.y, target = node.x)

# Since the inflows are the last column, we add the suffix to the sector column
links_sim_inflows <- sim_inflows %>%
  mutate(sector = str_c(sector, '1')) %>%
  left_join(sim_nodes, by = c('name')) %>%
  left_join(sim_nodes, by = c('sector' = 'name')) %>%
  rename(source = node.x, target = node.y)

```

8. We combine the two datasets, select the relevant columns, and rename them:

```{r}
links_sim <- bind_rows(links_sim_outflows, links_sim_inflows) %>%
  select(source, target, value)
```

9. We plot the Sankey's diagram:
```{r}
sim_nodes1 <- sim_nodes %>%
  mutate(name = case_when(
    name == 'C' ~ 'Consumption',
    name == 'G' ~ 'Gvt. Expenditures',
    name == 'H' ~ str_c('\u0394', ' Monetary balances'),
    name == 'WB' ~ 'Wage Bills',
    name == 'TX' ~ 'Taxes',
    str_detect(name, 'pr') ~ 'Firms',
    str_detect(name, 'gvt') ~ 'Government',
    T ~ 'Households'
  ))


sn <- networkD3::sankeyNetwork(Links = as.data.frame(links_sim), Nodes = as.data.frame(sim_nodes1), 
                          Source = 'source', 
                          Target = 'target', 
                          Value = 'value', 
                          NodeID = 'name',
                          units = 'dollars',
                          fontSize = 14)

htmlwidgets::onRender(sn, 'function(el) { el.querySelector("svg").removeAttribute("viewBox") }')

```


# Sankey's 2 (ggalluvial method)

If you like the `ggplot2` way of making graphs, the `ggalluvial` package is the way.

It must be said, though, that alluvial plots are slightly different than Sankey's diagram. More information can be retrieved [in this book](https://rkabacoff.github.io/datavis/Other.html#flow-diagrams).

It's easier to see the logic using the wider method: you have three axis, and one column of values.

```{r}
dt_wide <- bind_cols(sim_outflows, sim_inflows) %>%
  select(3, 1, 6, 2) %>%
  set_names('sector1', 'flows', 'sector2', 'value') 

dt_wide %>%
  ggplot(aes(axis1 = sector1, axis2 = flows, axis3 = sector2,
           y = value)) +
  scale_x_discrete(limits = c("sector1", "flows", "sector2")) +
  xlab("") +
  geom_alluvium() +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  theme_minimal()
```

However, as usually is the case with ggplot graphs, you have much more control using the long format.

Here's how you should transform the data:
```{r}
dt_long <- dt_wide %>%
  mutate(id = row_number()) %>%
  pivot_longer(cols = c(sector1, flows, sector2), values_to = 'stratum')
dt_long
```
With the transformed data, you can correct the naming and plot it!

```{r}
dt_long %>%
  mutate(stratum = case_when(
    stratum == 'C' ~ 'Consumption',
    stratum == 'G' ~ 'Gvt. Expenditures',
    stratum == 'H' ~ str_c('\u0394', ' Monetary balances'),
    stratum == 'WB' ~ 'Wage Bills',
    stratum == 'TX' ~ 'Taxes',
    str_detect(stratum, 'pr') ~ 'Firms',
    str_detect(stratum, 'gvt') ~ 'Government',
    T ~ 'Households'
  )) %>%
  mutate(name = fct_relevel(name, c('sector1', 'flows', 'sector2'))) %>%
  ggplot(aes(x = name, stratum = stratum, alluvium = id, y = value,
           label = stratum)) +
  scale_fill_brewer(type = "qual", palette = "Dark2") +
  geom_flow(stat = "alluvium", lode.guidance = "frontback",
            color = "darkgray") +
  geom_stratum(aes(fill = stratum)) +
  ggrepel::geom_label_repel(stat = "stratum", size = 3) +
  theme_void() +
  theme(legend.position = "none")
  
```

The alluvial method might be more consistent in its syntax, but it is, in my opinion, uglier, and do not represent small values (like monetary balances in this example) well.

## Session info
```{r}
sessionInfo()
```

## References

