---
title: Sankey's diagram in R
author: João Pedro S. Macalós
date: '2020-10-17'
slug: sankey-s-diagram-in-r
categories: [sfc]
tags: [sfc]
subtitle: ''
summary: ''
authors: []
lastmod: '2020-10-17T12:36:10+02:00'
featured: true
image:
  placement: 2
  focal_point: "Center"
  preview_only: true
projects: [sfc]
#output: blogdown::html_page
bibliography: references.bib
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<script src="/rmarkdown-libs/htmlwidgets/htmlwidgets.js"></script>
<script src="/rmarkdown-libs/d3/d3.min.js"></script>
<script src="/rmarkdown-libs/sankey/sankey.js"></script>
<script src="/rmarkdown-libs/sankeyNetwork-binding/sankeyNetwork.js"></script>


<p>In this post I will explain how to create a Sankey’s diagram to visualize a transactions-flow matrix of a SFC model.</p>
<p>Load packages and the main functions of the <code>sfc</code> package (under construction):</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## -- Attaching packages ---------------------------------------------------------------------------------------------------- tidyverse 1.3.0 --</code></pre>
<pre><code>## v ggplot2 3.3.2     v purrr   0.3.4
## v tibble  3.0.3     v dplyr   1.0.2
## v tidyr   1.1.2     v stringr 1.4.0
## v readr   1.3.1     v forcats 0.5.0</code></pre>
<pre><code>## -- Conflicts ------------------------------------------------------------------------------------------------------- tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<pre class="r"><code>library(formula.tools)
library(catchr)
library(blogdown)


source(&#39;../../../../sfc/gen_steady_todo.R&#39;)</code></pre>
<pre><code>## Warning: `collect` has special meaning as catchr input, but seems to
## already be defined elsewhere. These previous definitions may be masked
## when determining condition behavior. (To turn these warnings off, use
## `catchr_default_opts(warn_about_terms=FALSE)`.)</code></pre>
<pre class="r"><code>##### Not in operator
&#39;%!in%&#39; &lt;- function(x,y)!(&#39;%in%&#39;(x,y))</code></pre>
<p>The objective of this notebook is to show how to simulate the chapter 3 model (SIM model) of <span class="citation">Godley and Lavoie (2007)</span>.</p>
<div id="sim-model" class="section level1">
<h1>SIM model</h1>
<ul>
<li>(Godley and Lavoie, ch. 3)</li>
</ul>
<p>Define sectoral equations</p>
<pre class="r"><code>households &lt;- list(
  eh1 &lt;- TX_s[t] ~ TX_d[t],
  eh2 &lt;- YD[t] ~ W * N_s[t] - TX_s[t],
  eh3 &lt;- C_d[t] ~ parh2 * YD[t] + parh3 * H_h[t-1],
  eh4 &lt;- H_h[t] ~ YD[t] - C_d[t] + H_h[t-1],
  eh5 &lt;- N_s[t] ~ N_d[t]
)

production &lt;- list(
  ep1 &lt;- N_d[t] ~ Y[t] / W,
  ep2 &lt;- C_s[t] ~ C_d[t],
  ep3 &lt;- G_s[t] ~ G_d[t],
  ep4 &lt;- Y[t] ~ C_s[t] + G_s[t]
  
)

government &lt;- list(
  eg1 &lt;- TX_d[t] ~ parh1 * W * N_s[t],
  eg2 &lt;- H_s[t] ~ G_d[t] - TX_d[t] + H_s[t-1]
)</code></pre>
<p>Generate the model</p>
<pre class="r"><code>mod_sim &lt;- gen_steady(sectors = list(households, production, government), 
                      t = 60,
                      exogenous = list(G_d = 20), parameters = list(W = 1, parh1 = 0.2, parh2 = 0.6, parh3 = 0.4))</code></pre>
</div>
<div id="sankeys-diagram" class="section level1">
<h1>Sankey’s diagram</h1>
<ol style="list-style-type: decimal">
<li>Calculate the variation in monetary balances and multiple the supply/demand for work by wages:</li>
</ol>
<pre class="r"><code>mod_sim &lt;- mod_sim %&gt;%
  mutate(across(c(H_s, H_h), ~.x - lag(.x)),
         across(c(N_s, N_d), ~.x * W)) %&gt;%
  select(-W) %&gt;%
  drop_na()</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Save the last observation, as we want the diagram in the steady state:</li>
</ol>
<pre class="r"><code>sim_ss &lt;- mod_sim %&gt;% slice(59)</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Look at the transactions matrix, as we need to reshape the data according to it.</li>
</ol>
<p>We must exclude the items that are not there, like disposable income (YD), Y, W, and the parameters:</p>
<pre class="r"><code>sim_ss &lt;- sim_ss %&gt;%
  pivot_longer(cols = -row_id) %&gt;%
  filter(name %!in% c(&#39;YD&#39;, &#39;Y&#39;)) %&gt;%
  filter(!str_detect(name, &#39;par&#39;))
sim_ss</code></pre>
<pre><code>## # A tibble: 10 x 3
##    row_id name       value
##     &lt;int&gt; &lt;chr&gt;      &lt;dbl&gt;
##  1     60 TX_s   20.0     
##  2     60 C_d    80.0     
##  3     60 H_h     0.000752
##  4     60 N_s   100.      
##  5     60 N_d   100.      
##  6     60 C_s    80.0     
##  7     60 G_s    20       
##  8     60 TX_d   20.0     
##  9     60 H_s     0.00447 
## 10     60 G_d    20</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>Consolidate the entries to have one per row on the transactions matrix:</li>
</ol>
<pre class="r"><code>sim_ss &lt;- sim_ss %&gt;%
  mutate(name = str_remove_all(name, &#39;_.&#39;)) %&gt;%
  group_by(name) %&gt;%
  summarize(value = mean(value)) %&gt;%
  mutate(name = if_else(name == &#39;N&#39;, &#39;WB&#39;, name))</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>sim_ss</code></pre>
<pre><code>## # A tibble: 5 x 2
##   name      value
##   &lt;chr&gt;     &lt;dbl&gt;
## 1 C      80.0    
## 2 G      20      
## 3 H       0.00261
## 4 WB    100.     
## 5 TX     20.0</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>Map these flows with sectors, one tibble for inflows (+) and one for outflows (-):</li>
</ol>
<pre class="r"><code># Inflows (+ in the matrix)
sim_inflows &lt;- sim_ss %&gt;%
  mutate(sector = case_when(
    name == &#39;C&#39; ~ &#39;pr&#39;,
    name == &#39;G&#39; ~ &#39;pr&#39;,
    name == &#39;H&#39; ~ &#39;gvt&#39;,
    name == &#39;WB&#39; ~ &#39;hh&#39;,
    name == &#39;TX&#39; ~ &#39;gvt&#39;
  ))

# Outflows (- in the matrix)
sim_outflows &lt;- sim_ss %&gt;%
  mutate(sector = case_when(
    name == &#39;C&#39; ~ &#39;hh&#39;,
    name == &#39;G&#39; ~ &#39;gvt&#39;,
    name == &#39;H&#39; ~ &#39;hh&#39;,
    name == &#39;WB&#39; ~ &#39;pr&#39;,
    name == &#39;TX&#39; ~ &#39;hh&#39;
  ))</code></pre>
<p>We are ready to load the <code>networkD3</code> package. I do recommend <a href="https://towardsdatascience.com/using-networkd3-in-r-to-create-simple-and-clear-sankey-diagrams-48f8ba8a4ace">this article</a> as it was the best tutorial I found on the internet on how to draw Sankey’s diagrams on R.</p>
<p>Here, we must remember that a SFC Sankey’s diagram is structured in three columns:</p>
<blockquote>
<p>sector (outflows) <span class="math inline">\(\rightarrow\)</span> flows <span class="math inline">\(\rightarrow\)</span> sector (inflows)</p>
</blockquote>
<ol start="6" style="list-style-type: decimal">
<li>Create the <code>nodes</code> tibble:</li>
</ol>
<p>The objects in these columns are the <code>nodes</code> of the Sankey’s diagram. They are the unique <code>name</code> entries (flows) and <code>sector</code> entries of the inflows and outflows tibbles. Since we repeat the sectors column, we must differentiate them in the code. I will do it by adding a numerical suffix to them.</p>
<p>Finally, we must give each unique entry a numeric id. Importantly, it must be zero indexed.</p>
<pre class="r"><code>library(networkD3)

sim_nodes &lt;- tibble(name = c(unique(sim_inflows$name), 
                 unique(sim_inflows$sector), 
                 str_c(unique(sim_inflows$sector), &#39;1&#39;)),
       node = 0:10)</code></pre>
<ol start="7" style="list-style-type: decimal">
<li>Create the <code>links</code> tibble:</li>
</ol>
<p>We do it by first <code>left_join</code>ing the data on names, and then on sector. The order of the joins matter. The first column <code>node.x</code> will map the flows and the second column <code>node.y</code> will map the sectors.</p>
<pre class="r"><code>links_sim_outflows &lt;- sim_outflows %&gt;%
  left_join(sim_nodes, by = c(&#39;name&#39;)) %&gt;%
  left_join(sim_nodes, by = c(&#39;sector&#39; = &#39;name&#39;)) %&gt;%
  rename(source = node.y, target = node.x)

# Since the inflows are the last column, we add the suffix to the sector column
links_sim_inflows &lt;- sim_inflows %&gt;%
  mutate(sector = str_c(sector, &#39;1&#39;)) %&gt;%
  left_join(sim_nodes, by = c(&#39;name&#39;)) %&gt;%
  left_join(sim_nodes, by = c(&#39;sector&#39; = &#39;name&#39;)) %&gt;%
  rename(source = node.x, target = node.y)</code></pre>
<ol start="8" style="list-style-type: decimal">
<li>We combine the two datasets, select the relevant columns, and rename them:</li>
</ol>
<pre class="r"><code>links_sim &lt;- bind_rows(links_sim_outflows, links_sim_inflows) %&gt;%
  select(source, target, value)</code></pre>
<ol start="9" style="list-style-type: decimal">
<li>We plot the Sankey’s diagram:</li>
</ol>
<pre class="r"><code>sim_nodes1 &lt;- sim_nodes %&gt;%
  mutate(name = case_when(
    name == &#39;C&#39; ~ &#39;Consumption&#39;,
    name == &#39;G&#39; ~ &#39;Gvt. Expenditures&#39;,
    name == &#39;H&#39; ~ str_c(&#39;\u0394&#39;, &#39; Monetary balances&#39;),
    name == &#39;WB&#39; ~ &#39;Wage Bills&#39;,
    name == &#39;TX&#39; ~ &#39;Taxes&#39;,
    str_detect(name, &#39;pr&#39;) ~ &#39;Firms&#39;,
    str_detect(name, &#39;gvt&#39;) ~ &#39;Government&#39;,
    T ~ &#39;Households&#39;
  ))


sn &lt;- networkD3::sankeyNetwork(Links = as.data.frame(links_sim), Nodes = as.data.frame(sim_nodes1), 
                          Source = &#39;source&#39;, 
                          Target = &#39;target&#39;, 
                          Value = &#39;value&#39;, 
                          NodeID = &#39;name&#39;,
                          units = &#39;dollars&#39;,
                          fontSize = 14)

htmlwidgets::onRender(sn, &#39;function(el) { el.querySelector(&quot;svg&quot;).removeAttribute(&quot;viewBox&quot;) }&#39;)</code></pre>
<div id="htmlwidget-1" style="width:672px;height:480px;" class="sankeyNetwork html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"links":{"source":[7,6,7,5,7,0,1,2,3,4],"target":[0,1,2,3,4,8,8,9,10,9],"value":[79.9813074867666,20,0.00261138320718146,99.9776461578679,19.9955220513811,79.9813074867666,20,0.00261138320718146,99.9776461578679,19.9955220513811]},"nodes":{"name":["Consumption","Gvt. Expenditures","Δ Monetary balances","Wage Bills","Taxes","Firms","Government","Households","Firms","Government","Households"],"group":["Consumption","Gvt. Expenditures","Δ Monetary balances","Wage Bills","Taxes","Firms","Government","Households","Firms","Government","Households"]},"options":{"NodeID":"name","NodeGroup":"name","LinkGroup":null,"colourScale":"d3.scaleOrdinal(d3.schemeCategory20);","fontSize":14,"fontFamily":null,"nodeWidth":15,"nodePadding":10,"units":"dollars","margin":{"top":null,"right":null,"bottom":null,"left":null},"iterations":32,"sinksRight":true}},"evals":[],"jsHooks":{"render":[{"code":"function(el) { el.querySelector(\"svg\").removeAttribute(\"viewBox\") }","data":null}]}}</script>
</div>
<div id="sankeys-2-ggalluvial-method" class="section level1">
<h1>Sankey’s 2 (ggalluvial method)</h1>
<p>If you like the <code>ggplot2</code> way of making graphs, the <code>ggalluvial</code> package is the way.</p>
<p>It must be said, though, that alluvial plots are slightly different than Sankey’s diagram. More information can be retrieved <a href="https://rkabacoff.github.io/datavis/Other.html#flow-diagrams">in this book</a>.</p>
<p>It’s easier to see the logic using the wider method: you have three axis, and one column of values.</p>
<pre class="r"><code>library(ggalluvial)

dt_wide &lt;- bind_cols(sim_outflows, sim_inflows) %&gt;%
  select(3, 1, 6, 2) %&gt;%
  set_names(&#39;sector1&#39;, &#39;flows&#39;, &#39;sector2&#39;, &#39;value&#39;) </code></pre>
<pre><code>## New names:
## * name -&gt; name...1
## * value -&gt; value...2
## * sector -&gt; sector...3
## * name -&gt; name...4
## * value -&gt; value...5
## * ...</code></pre>
<pre class="r"><code>dt_wide %&gt;%
  ggplot(aes(axis1 = sector1, axis2 = flows, axis3 = sector2,
           y = value)) +
  scale_x_discrete(limits = c(&quot;sector1&quot;, &quot;flows&quot;, &quot;sector2&quot;)) +
  xlab(&quot;&quot;) +
  geom_alluvium() +
  geom_stratum() +
  geom_text(stat = &quot;stratum&quot;, aes(label = after_stat(stratum))) +
  theme_minimal()</code></pre>
<pre><code>## Warning in to_lodes_form(data = data, axes = axis_ind, discern =
## params$discern): Some strata appear at multiple axes.

## Warning in to_lodes_form(data = data, axes = axis_ind, discern =
## params$discern): Some strata appear at multiple axes.

## Warning in to_lodes_form(data = data, axes = axis_ind, discern =
## params$discern): Some strata appear at multiple axes.</code></pre>
<p><img src="/post/2020-10-17-sankey/index_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>However, as usually is the case with ggplot graphs, you have much more control using the long format.</p>
<p>Here’s how you should transform the data:</p>
<pre class="r"><code>dt_long &lt;- dt_wide %&gt;%
  mutate(id = row_number()) %&gt;%
  pivot_longer(cols = c(sector1, flows, sector2), values_to = &#39;stratum&#39;)
dt_long</code></pre>
<pre><code>## # A tibble: 15 x 4
##        value    id name    stratum
##        &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  
##  1  80.0         1 sector1 hh     
##  2  80.0         1 flows   C      
##  3  80.0         1 sector2 pr     
##  4  20           2 sector1 gvt    
##  5  20           2 flows   G      
##  6  20           2 sector2 pr     
##  7   0.00261     3 sector1 hh     
##  8   0.00261     3 flows   H      
##  9   0.00261     3 sector2 gvt    
## 10 100.          4 sector1 pr     
## 11 100.          4 flows   WB     
## 12 100.          4 sector2 hh     
## 13  20.0         5 sector1 hh     
## 14  20.0         5 flows   TX     
## 15  20.0         5 sector2 gvt</code></pre>
<p>With the transformed data, you can correct the naming and plot it!</p>
<pre class="r"><code>dt_long %&gt;%
  mutate(stratum = case_when(
    stratum == &#39;C&#39; ~ &#39;Consumption&#39;,
    stratum == &#39;G&#39; ~ &#39;Gvt. Expenditures&#39;,
    stratum == &#39;H&#39; ~ str_c(&#39;\u0394&#39;, &#39; Monetary balances&#39;),
    stratum == &#39;WB&#39; ~ &#39;Wage Bills&#39;,
    stratum == &#39;TX&#39; ~ &#39;Taxes&#39;,
    str_detect(stratum, &#39;pr&#39;) ~ &#39;Firms&#39;,
    str_detect(stratum, &#39;gvt&#39;) ~ &#39;Government&#39;,
    T ~ &#39;Households&#39;
  )) %&gt;%
  mutate(name = fct_relevel(name, c(&#39;sector1&#39;, &#39;flows&#39;, &#39;sector2&#39;))) %&gt;%
  ggplot(aes(x = name, stratum = stratum, alluvium = id, y = value,
           label = stratum)) +
  scale_fill_brewer(type = &quot;qual&quot;, palette = &quot;Dark2&quot;) +
  geom_flow(stat = &quot;alluvium&quot;, lode.guidance = &quot;frontback&quot;,
            color = &quot;darkgray&quot;) +
  geom_stratum(aes(fill = stratum)) +
  ggrepel::geom_label_repel(stat = &quot;stratum&quot;, size = 3) +
  theme_void() +
  theme(legend.position = &quot;none&quot;)</code></pre>
<p><img src="/post/2020-10-17-sankey/index_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>The alluvial method might be more consistent in its syntax, but it is, in my opinion, uglier, and do not represent small values (like monetary balances in this example) well.</p>
<div id="session-info" class="section level2">
<h2>Session info</h2>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.6.3 (2020-02-29)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 19041)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=English_United States.1252 
## [2] LC_CTYPE=English_United States.1252   
## [3] LC_MONETARY=English_United States.1252
## [4] LC_NUMERIC=C                          
## [5] LC_TIME=English_United States.1252    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] ggalluvial_0.12.2   networkD3_0.4       blogdown_0.18      
##  [4] catchr_0.2.3        formula.tools_1.7.1 forcats_0.5.0      
##  [7] stringr_1.4.0       dplyr_1.0.2         purrr_0.3.4        
## [10] readr_1.3.1         tidyr_1.1.2         tibble_3.0.3       
## [13] ggplot2_3.3.2       tidyverse_1.3.0    
## 
## loaded via a namespace (and not attached):
##  [1] ggrepel_0.8.2        Rcpp_1.0.4.6         lubridate_1.7.8     
##  [4] assertthat_0.2.1     digest_0.6.25        utf8_1.1.4          
##  [7] R6_2.4.1             cellranger_1.1.0     backports_1.1.6     
## [10] reprex_0.3.0         evaluate_0.14        httr_1.4.1          
## [13] pillar_1.4.4         rlang_0.4.7          readxl_1.3.1        
## [16] rstudioapi_0.11      rmarkdown_2.3        labeling_0.3        
## [19] htmlwidgets_1.5.1    igraph_1.2.4.1       munsell_0.5.0       
## [22] broom_0.7.0          compiler_3.6.3       modelr_0.1.6        
## [25] xfun_0.13            pkgconfig_2.0.3      htmltools_0.4.0     
## [28] tidyselect_1.1.0     bookdown_0.20        fansi_0.4.1         
## [31] crayon_1.3.4         dbplyr_1.4.2         withr_2.1.2         
## [34] grid_3.6.3           jsonlite_1.6.1       gtable_0.3.0        
## [37] lifecycle_0.2.0      DBI_1.1.0            magrittr_1.5        
## [40] scales_1.1.0         cli_2.0.2            stringi_1.4.3       
## [43] farver_2.0.3         fs_1.4.1             xml2_1.3.1          
## [46] ellipsis_0.3.0       generics_0.0.2       vctrs_0.3.4         
## [49] RColorBrewer_1.1-2   tools_3.6.3          Cairo_1.5-11        
## [52] glue_1.4.0           hms_0.5.3            yaml_2.2.1          
## [55] colorspace_1.4-1     operator.tools_1.6.3 rvest_0.3.5         
## [58] knitr_1.28           haven_2.2.0</code></pre>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references hanging-indent">
<div id="ref-godley2007monetary">
<p>Godley, Wynne, and Marc Lavoie. 2007. <em>Monetary Economics: An Integrated Approach to Credit, Money, Income, Production and Wealth</em>. Palgrave Macmillan.</p>
</div>
</div>
</div>
</div>
